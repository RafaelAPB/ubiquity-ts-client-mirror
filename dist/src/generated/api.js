"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Ubiquity REST API
 * Ubiquity provides a RESTful and uniform way to access blockchain resources, with a rich and reusable model across multiple cryptocurrencies.  [Documentation](https://app.blockdaemon.com/docs/ubiquity)  ### Protocols #### Mainnet The following protocols are currently supported: * bitcoin * ethereum * polkadot * xrp * algorand * stellar * dogecoin * oasis * near * terra * litecoin * bitcoincash * tezos  #### Testnet * bitcoin/testnet * ethereum/ropsten * dogecoin/testnet * litecoin/testnet * bitcoincash/testnet  #### Native Ubiquity provides native access to all Blockchain nodes it supports. * bitcoin/(mainnet | testnet) - [RPC Documentation](https://developer.bitcoin.org/reference/rpc/) * ethereum/(mainnet | ropsten) - [RPC Documentation](https://ethereum.org/en/developers/docs/apis/json-rpc/) * polkadot/mainnet - [Sidecar API Documentation](https://paritytech.github.io/substrate-api-sidecar/dist/) * polkadot/mainnet/http-rpc - [Polkadot RPC Documentation](https://polkadot.js.org/docs/substrate/rpc/) * algorand/mainnet - [Algod API Documentation](https://developer.algorand.org/docs/reference/rest-apis/algod/) * stellar/mainnet - [Stellar Horizon API Documentation](https://developers.stellar.org/api) * dogecoin/(mainnet | testnet) - [Dogecoin API Documentaion](https://developer.bitcoin.org/reference/rpc/) * oasis/mainnet - [Oasis Rosetta Gateway Documentation](https://www.rosetta-api.org/docs/api_identifiers.html#network-identifier) * near/mainnet - [NEAR RPC Documentation](https://docs.near.org/docs/api/rpc) * terra/mainnet - [Terra RPC Documentation](https://docs.terra.money/docs/develop/how-to/endpoints.html) * litecoin/mainnet - [Litecoin RPC Documentation](https://litecoin.info/index.php/Litecoin_API) * bitcoincash/mainnet - [Bitcoin Cash RPC Documentation](https://docs.bitcoincashnode.org/doc/json-rpc/) * tezos/mainnet - [Tezos RPC Documentation](https://tezos.gitlab.io/developer/rpc.html)   A full URL example: https://ubiquity.api.blockdaemon.com/v1/bitcoin/mainnet  ##### Pagination Certain resources contain a lot of data, more than what\'s practical to return for a single request. With the help of pagination, the data is split across multiple responses. Each response returns a subset of the items requested, and a continuation token.  To get the next batch of items, copy the returned continuation token to the continuation query parameter and repeat the request with the new URL. In case no continuation token is returned, there is no more data available.
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: support@blockdaemon.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionsApi = exports.TransactionsApiFactory = exports.TransactionsApiFp = exports.TransactionsApiAxiosParamCreator = exports.SyncApi = exports.SyncApiFactory = exports.SyncApiFp = exports.SyncApiAxiosParamCreator = exports.PlatformsApi = exports.PlatformsApiFactory = exports.PlatformsApiFp = exports.PlatformsApiAxiosParamCreator = exports.NFTApi = exports.NFTApiFactory = exports.NFTApiFp = exports.NFTApiAxiosParamCreator = exports.BlocksApi = exports.BlocksApiFactory = exports.BlocksApiFp = exports.BlocksApiAxiosParamCreator = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.TxOutputStatusEnum = exports.TxStatusEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var TxStatusEnum;
(function (TxStatusEnum) {
    TxStatusEnum["Completed"] = "completed";
    TxStatusEnum["Failed"] = "failed";
})(TxStatusEnum = exports.TxStatusEnum || (exports.TxStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TxOutputStatusEnum;
(function (TxOutputStatusEnum) {
    TxOutputStatusEnum["Mined"] = "mined";
    TxOutputStatusEnum["Unknown"] = "unknown";
})(TxOutputStatusEnum = exports.TxOutputStatusEnum || (exports.TxOutputStatusEnum = {}));
/**
 * AccountsApi - axios parameter creator
 * @export
 */
const AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the account balances for all supported currencies.
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddress: (platform, network, address, assets, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getListOfBalancesByAddress', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getListOfBalancesByAddress', 'network', network);
            // verify required parameter 'address' is not null or undefined
            common_1.assertParamExists('getListOfBalancesByAddress', 'address', address);
            const localVarPath = `/{platform}/{network}/account/{address}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the balances of accounts for all supported currencies.
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddresses: (platform, network, accountsObj, assets, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getListOfBalancesByAddresses', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getListOfBalancesByAddresses', 'network', network);
            // verify required parameter 'accountsObj' is not null or undefined
            common_1.assertParamExists('getListOfBalancesByAddresses', 'accountsObj', accountsObj);
            const localVarPath = `/{platform}/{network}/accounts`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accountsObj, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns account activity
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k.
         * @param {string} [continuation] Continuation token from earlier response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportByAddress: (platform, network, address, from, to, limit, continuation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getReportByAddress', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getReportByAddress', 'network', network);
            // verify required parameter 'address' is not null or undefined
            common_1.assertParamExists('getReportByAddress', 'address', address);
            const localVarPath = `/{platform}/{network}/account/{address}/report`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination.
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress: (platform, network, address, order, continuation, limit, assets, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getTxsByAddress', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getTxsByAddress', 'network', network);
            // verify required parameter 'address' is not null or undefined
            common_1.assertParamExists('getTxsByAddress', 'address', address);
            const localVarPath = `/{platform}/{network}/account/{address}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
const AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AccountsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the account balances for all supported currencies.
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddress(platform, network, address, assets, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getListOfBalancesByAddress(platform, network, address, assets, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the balances of accounts for all supported currencies.
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddresses(platform, network, accountsObj, assets, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getListOfBalancesByAddresses(platform, network, accountsObj, assets, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns account activity
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k.
         * @param {string} [continuation] Continuation token from earlier response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportByAddress(platform, network, address, from, to, limit, continuation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getReportByAddress(platform, network, address, from, to, limit, continuation, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination.
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress(platform, network, address, order, continuation, limit, assets, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTxsByAddress(platform, network, address, order, continuation, limit, assets, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
const AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AccountsApiFp(configuration);
    return {
        /**
         * Returns the account balances for all supported currencies.
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddress(platform, network, address, assets, options) {
            return localVarFp.getListOfBalancesByAddress(platform, network, address, assets, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the balances of accounts for all supported currencies.
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddresses(platform, network, accountsObj, assets, options) {
            return localVarFp.getListOfBalancesByAddresses(platform, network, accountsObj, assets, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns account activity
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k.
         * @param {string} [continuation] Continuation token from earlier response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportByAddress(platform, network, address, from, to, limit, continuation, options) {
            return localVarFp.getReportByAddress(platform, network, address, from, to, limit, continuation, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination.
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress(platform, network, address, order, continuation, limit, assets, options) {
            return localVarFp.getTxsByAddress(platform, network, address, order, continuation, limit, assets, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Returns the account balances for all supported currencies.
     * @summary Balances Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getListOfBalancesByAddress(platform, network, address, assets, options) {
        return exports.AccountsApiFp(this.configuration).getListOfBalancesByAddress(platform, network, address, assets, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the balances of accounts for all supported currencies.
     * @summary Balances Of Addresses
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {AccountsObj} accountsObj
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getListOfBalancesByAddresses(platform, network, accountsObj, assets, options) {
        return exports.AccountsApiFp(this.configuration).getListOfBalancesByAddresses(platform, network, accountsObj, assets, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns account activity
     * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {number} [from] Unix Timestamp from where to start
     * @param {number} [to] Unix Timestamp from where to end
     * @param {number} [limit] Max number of items to return in a response. Defaults to 50k and is capped at 100k.
     * @param {string} [continuation] Continuation token from earlier response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getReportByAddress(platform, network, address, from, to, limit, continuation, options) {
        return exports.AccountsApiFp(this.configuration).getReportByAddress(platform, network, address, from, to, limit, continuation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination.
     * @summary Transactions Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getTxsByAddress(platform, network, address, order, continuation, limit, assets, options) {
        return exports.AccountsApiFp(this.configuration).getTxsByAddress(platform, network, address, order, continuation, limit, assets, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * BlocksApi - axios parameter creator
 * @export
 */
const BlocksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: (platform, network, key, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getBlock', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getBlock', 'network', network);
            // verify required parameter 'key' is not null or undefined
            common_1.assertParamExists('getBlock', 'key', key);
            const localVarPath = `/{platform}/{network}/block/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier: (platform, network, key, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getBlockIdentifier', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getBlockIdentifier', 'network', network);
            // verify required parameter 'key' is not null or undefined
            common_1.assertParamExists('getBlockIdentifier', 'key', key);
            const localVarPath = `/{platform}/{network}/block_identifier/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get minimal block identifiers from oldest to newest. This call uses pagination.
         * @summary Block Identifiers
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifiers: (platform, network, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getBlockIdentifiers', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getBlockIdentifiers', 'network', network);
            const localVarPath = `/{platform}/{network}/block_identifiers`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BlocksApiAxiosParamCreator = BlocksApiAxiosParamCreator;
/**
 * BlocksApi - functional programming interface
 * @export
 */
const BlocksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.BlocksApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(platform, network, key, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBlock(platform, network, key, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier(platform, network, key, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBlockIdentifier(platform, network, key, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get minimal block identifiers from oldest to newest. This call uses pagination.
         * @summary Block Identifiers
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifiers(platform, network, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBlockIdentifiers(platform, network, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.BlocksApiFp = BlocksApiFp;
/**
 * BlocksApi - factory interface
 * @export
 */
const BlocksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.BlocksApiFp(configuration);
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(platform, network, key, options) {
            return localVarFp.getBlock(platform, network, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier(platform, network, key, options) {
            return localVarFp.getBlockIdentifier(platform, network, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get minimal block identifiers from oldest to newest. This call uses pagination.
         * @summary Block Identifiers
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifiers(platform, network, options) {
            return localVarFp.getBlockIdentifiers(platform, network, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BlocksApiFactory = BlocksApiFactory;
/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
class BlocksApi extends base_1.BaseAPI {
    /**
     * Get a block and all its transactions by the block number or hash
     * @summary Block By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    getBlock(platform, network, key, options) {
        return exports.BlocksApiFp(this.configuration).getBlock(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get minimal block identifier by block number or hash
     * @summary Block Identifier By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    getBlockIdentifier(platform, network, key, options) {
        return exports.BlocksApiFp(this.configuration).getBlockIdentifier(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get minimal block identifiers from oldest to newest. This call uses pagination.
     * @summary Block Identifiers
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    getBlockIdentifiers(platform, network, options) {
        return exports.BlocksApiFp(this.configuration).getBlockIdentifiers(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BlocksApi = BlocksApi;
/**
 * NFTApi - axios parameter creator
 * @export
 */
const NFTApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerGetCollection: (protocol, network, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'protocol' is not null or undefined
            common_1.assertParamExists('explorerGetCollection', 'protocol', protocol);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('explorerGetCollection', 'network', network);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('explorerGetCollection', 'id', id);
            const localVarPath = `/nft/{protocol}/{network}/collection/{id}`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
         * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
         * @param {number} [tokenIdValue] The int64 value.
         * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
         * @param {string} [sortBy] One of: name, token_id, mint_date
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListAssets: (protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'protocol' is not null or undefined
            common_1.assertParamExists('explorerListAssets', 'protocol', protocol);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('explorerListAssets', 'network', network);
            const localVarPath = `/nft/{protocol}/{network}/assets`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (walletAddress !== undefined) {
                localVarQueryParameter['wallet_address'] = walletAddress;
            }
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (tokenIdValue !== undefined) {
                localVarQueryParameter['token_id.value'] = tokenIdValue;
            }
            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }
            if (attributes) {
                localVarQueryParameter['attributes'] = attributes;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
         * @param {string} [sortBy] Sort by one of: name
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListCollections: (protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'protocol' is not null or undefined
            common_1.assertParamExists('explorerListCollections', 'protocol', protocol);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('explorerListCollections', 'network', network);
            const localVarPath = `/nft/{protocol}/{network}/collections`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (contractAddress) {
                localVarQueryParameter['contractAddress'] = contractAddress;
            }
            if (collectionName) {
                localVarQueryParameter['collectionName'] = collectionName;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
         * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
         * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
         * @param {string} [sortBy] Sort by one of: timestamp
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListEvents: (protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'protocol' is not null or undefined
            common_1.assertParamExists('explorerListEvents', 'protocol', protocol);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('explorerListEvents', 'network', network);
            const localVarPath = `/nft/{protocol}/{network}/events`
                .replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (walletAddress !== undefined) {
                localVarQueryParameter['wallet_address'] = walletAddress;
            }
            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }
            if (eventType !== undefined) {
                localVarQueryParameter['event_type'] = eventType;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NFTApiAxiosParamCreator = NFTApiAxiosParamCreator;
/**
 * NFTApi - functional programming interface
 * @export
 */
const NFTApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.NFTApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerGetCollection(protocol, network, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.explorerGetCollection(protocol, network, id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
         * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
         * @param {number} [tokenIdValue] The int64 value.
         * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
         * @param {string} [sortBy] One of: name, token_id, mint_date
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
         * @param {string} [sortBy] Sort by one of: name
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
         * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
         * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
         * @param {string} [sortBy] Sort by one of: timestamp
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NFTApiFp = NFTApiFp;
/**
 * NFTApi - factory interface
 * @export
 */
const NFTApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.NFTApiFp(configuration);
    return {
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerGetCollection(protocol, network, id, options) {
            return localVarFp.explorerGetCollection(protocol, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
         * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
         * @param {number} [tokenIdValue] The int64 value.
         * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
         * @param {string} [sortBy] One of: name, token_id, mint_date
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options) {
            return localVarFp.explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
         * @param {string} [sortBy] Sort by one of: name
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options) {
            return localVarFp.explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} protocol Coin platform handle
         * @param {string} network Which network to target
         * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
         * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
         * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
         * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
         * @param {string} [sortBy] Sort by one of: timestamp
         * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
         * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
         * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options) {
            return localVarFp.explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NFTApiFactory = NFTApiFactory;
/**
 * NFTApi - object-oriented interface
 * @export
 * @class NFTApi
 * @extends {BaseAPI}
 */
class NFTApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {string} id Mapped to URL query parameter \&#39;uuid\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    explorerGetCollection(protocol, network, id, options) {
        return exports.NFTApiFp(this.configuration).explorerGetCollection(protocol, network, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {string} [walletAddress] Mapped to URL query parameter &#x60;wallet_address&#x60;
     * @param {string} [contractAddress] Mapped to URL query parameter &#x60;contract_address&#x60;
     * @param {number} [tokenIdValue] The int64 value.
     * @param {string} [collectionName] Mapped to URL query parameter &#x60;collection_name&#x60;
     * @param {string} [sortBy] One of: name, token_id, mint_date
     * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
     * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
     * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
     * @param {Array<string>} [attributes] Mapped to URL query parameter &#x60;attributes&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options) {
        return exports.NFTApiFp(this.configuration).explorerListAssets(protocol, network, walletAddress, contractAddress, tokenIdValue, collectionName, sortBy, order, pageSize, pageToken, attributes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {Array<string>} [contractAddress] Mapped to URL query parameter \&#39;contract_address\&#39;
     * @param {Array<string>} [collectionName] Mapped to URL query parameter \&#39;collection_name\&#39;
     * @param {string} [sortBy] Sort by one of: name
     * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
     * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
     * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options) {
        return exports.NFTApiFp(this.configuration).explorerListCollections(protocol, network, contractAddress, collectionName, sortBy, order, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} protocol Coin platform handle
     * @param {string} network Which network to target
     * @param {string} [contractAddress] mapped to URL query parameter \&#39;contract_address\&#39;
     * @param {string} [walletAddress] mapped to URL query parameter \&#39;wallet_address\&#39;
     * @param {number} [tokenId] mapped to URL query parameter \&#39;token_id\&#39;
     * @param {string} [eventType] mapped to URL query parameter \&#39;event_type\&#39;
     * @param {string} [sortBy] Sort by one of: timestamp
     * @param {string} [order] Mapped to URL query parameter &#x60;order&#x60; One of: asc, desc
     * @param {number} [pageSize] Mapped to URL query parameter &#x60;page_size&#x60;
     * @param {string} [pageToken] Mapped to URL query parameter &#x60;page_token&#x60; base64 encoded cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTApi
     */
    explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options) {
        return exports.NFTApiFp(this.configuration).explorerListEvents(protocol, network, contractAddress, walletAddress, tokenId, eventType, sortBy, order, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NFTApi = NFTApi;
/**
 * PlatformsApi - axios parameter creator
 * @export
 */
const PlatformsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Provides information about supported endpoints and generic platform information.
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformEndpoints: (platform, network, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getPlatformEndpoints', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getPlatformEndpoints', 'network', network);
            const localVarPath = `/{platform}/{network}/`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Provides a list of supported platforms and networks.
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsList: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PlatformsApiAxiosParamCreator = PlatformsApiAxiosParamCreator;
/**
 * PlatformsApi - functional programming interface
 * @export
 */
const PlatformsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.PlatformsApiAxiosParamCreator(configuration);
    return {
        /**
         * Provides information about supported endpoints and generic platform information.
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformEndpoints(platform, network, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPlatformEndpoints(platform, network, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Provides a list of supported platforms and networks.
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPlatformsList(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PlatformsApiFp = PlatformsApiFp;
/**
 * PlatformsApi - factory interface
 * @export
 */
const PlatformsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.PlatformsApiFp(configuration);
    return {
        /**
         * Provides information about supported endpoints and generic platform information.
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformEndpoints(platform, network, options) {
            return localVarFp.getPlatformEndpoints(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides a list of supported platforms and networks.
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsList(options) {
            return localVarFp.getPlatformsList(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PlatformsApiFactory = PlatformsApiFactory;
/**
 * PlatformsApi - object-oriented interface
 * @export
 * @class PlatformsApi
 * @extends {BaseAPI}
 */
class PlatformsApi extends base_1.BaseAPI {
    /**
     * Provides information about supported endpoints and generic platform information.
     * @summary Platform Info
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    getPlatformEndpoints(platform, network, options) {
        return exports.PlatformsApiFp(this.configuration).getPlatformEndpoints(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Provides a list of supported platforms and networks.
     * @summary Platforms overview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    getPlatformsList(options) {
        return exports.PlatformsApiFp(this.configuration).getPlatformsList(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PlatformsApi = PlatformsApi;
/**
 * SyncApi - axios parameter creator
 * @export
 */
const SyncApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID: (platform, network, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('currentBlockID', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('currentBlockID', 'network', network);
            const localVarPath = `/{platform}/{network}/sync/block_id`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber: (platform, network, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('currentBlockNumber', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('currentBlockNumber', 'network', network);
            const localVarPath = `/{platform}/{network}/sync/block_number`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SyncApiAxiosParamCreator = SyncApiAxiosParamCreator;
/**
 * SyncApi - functional programming interface
 * @export
 */
const SyncApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SyncApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID(platform, network, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.currentBlockID(platform, network, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber(platform, network, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.currentBlockNumber(platform, network, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SyncApiFp = SyncApiFp;
/**
 * SyncApi - factory interface
 * @export
 */
const SyncApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SyncApiFp(configuration);
    return {
        /**
         *
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID(platform, network, options) {
            return localVarFp.currentBlockID(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber(platform, network, options) {
            return localVarFp.currentBlockNumber(platform, network, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SyncApiFactory = SyncApiFactory;
/**
 * SyncApi - object-oriented interface
 * @export
 * @class SyncApi
 * @extends {BaseAPI}
 */
class SyncApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get current block ID
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    currentBlockID(platform, network, options) {
        return exports.SyncApiFp(this.configuration).currentBlockID(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get current block number
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    currentBlockNumber(platform, network, options) {
        return exports.SyncApiFp(this.configuration).currentBlockNumber(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SyncApi = SyncApi;
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEstimate: (platform, network, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('feeEstimate', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('feeEstimate', 'network', network);
            const localVarPath = `/{platform}/{network}/tx/estimate_fee`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: (platform, network, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getTx', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getTx', 'network', network);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTx', 'id', id);
            const localVarPath = `/{platform}/{network}/tx/{id}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Transaction output by hash and index
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {number} index Transaction output index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxByHashAndIndex: (platform, network, id, index, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getTxByHashAndIndex', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getTxByHashAndIndex', 'network', network);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTxByHashAndIndex', 'id', id);
            // verify required parameter 'index' is not null or undefined
            common_1.assertParamExists('getTxByHashAndIndex', 'index', index);
            const localVarPath = `/{platform}/{network}/tx/{id}/{index}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Transaction confirmations By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxConfirmations: (platform, network, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getTxConfirmations', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getTxConfirmations', 'network', network);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTxConfirmations', 'id', id);
            const localVarPath = `/{platform}/{network}/tx/{id}/confirmations`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets transactions from oldest to newest. This call uses pagination.
         * @summary Latest transactions of a protocol
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs: (platform, network, order, continuation, limit, assets, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('getTxs', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('getTxs', 'network', network);
            const localVarPath = `/{platform}/{network}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets.
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSend: (platform, network, signedTx, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'platform' is not null or undefined
            common_1.assertParamExists('txSend', 'platform', platform);
            // verify required parameter 'network' is not null or undefined
            common_1.assertParamExists('txSend', 'network', network);
            // verify required parameter 'signedTx' is not null or undefined
            common_1.assertParamExists('txSend', 'signedTx', signedTx);
            const localVarPath = `/{platform}/{network}/tx/send`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(signedTx, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionsApiAxiosParamCreator = TransactionsApiAxiosParamCreator;
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TransactionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEstimate(platform, network, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.feeEstimate(platform, network, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(platform, network, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTx(platform, network, id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Transaction output by hash and index
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {number} index Transaction output index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxByHashAndIndex(platform, network, id, index, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTxByHashAndIndex(platform, network, id, index, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Transaction confirmations By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxConfirmations(platform, network, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTxConfirmations(platform, network, id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Gets transactions from oldest to newest. This call uses pagination.
         * @summary Latest transactions of a protocol
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs(platform, network, order, continuation, limit, assets, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTxs(platform, network, order, continuation, limit, assets, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets.
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSend(platform, network, signedTx, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.txSend(platform, network, signedTx, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TransactionsApiFp = TransactionsApiFp;
/**
 * TransactionsApi - factory interface
 * @export
 */
const TransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TransactionsApiFp(configuration);
    return {
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEstimate(platform, network, options) {
            return localVarFp.feeEstimate(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(platform, network, id, options) {
            return localVarFp.getTx(platform, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Transaction output by hash and index
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {number} index Transaction output index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxByHashAndIndex(platform, network, id, index, options) {
            return localVarFp.getTxByHashAndIndex(platform, network, id, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Transaction confirmations By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxConfirmations(platform, network, id, options) {
            return localVarFp.getTxConfirmations(platform, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets transactions from oldest to newest. This call uses pagination.
         * @summary Latest transactions of a protocol
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs(platform, network, order, continuation, limit, assets, options) {
            return localVarFp.getTxs(platform, network, order, continuation, limit, assets, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets.
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSend(platform, network, signedTx, options) {
            return localVarFp.txSend(platform, network, signedTx, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionsApiFactory = TransactionsApiFactory;
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends base_1.BaseAPI {
    /**
     * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow
     * @summary Get fee estimate
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    feeEstimate(platform, network, options) {
        return exports.TransactionsApiFp(this.configuration).feeEstimate(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Transaction By Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTx(platform, network, id, options) {
        return exports.TransactionsApiFp(this.configuration).getTx(platform, network, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Transaction output by hash and index
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {number} index Transaction output index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTxByHashAndIndex(platform, network, id, index, options) {
        return exports.TransactionsApiFp(this.configuration).getTxByHashAndIndex(platform, network, id, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Transaction confirmations By Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTxConfirmations(platform, network, id, options) {
        return exports.TransactionsApiFp(this.configuration).getTxConfirmations(platform, network, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets transactions from oldest to newest. This call uses pagination.
     * @summary Latest transactions of a protocol
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100.
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTxs(platform, network, order, continuation, limit, assets, options) {
        return exports.TransactionsApiFp(this.configuration).getTxs(platform, network, order, continuation, limit, assets, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets.
     * @summary Submit a signed transaction
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {SignedTx} signedTx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    txSend(platform, network, signedTx, options) {
        return exports.TransactionsApiFp(this.configuration).txSend(platform, network, signedTx, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionsApi = TransactionsApi;
