/* tslint:disable */
/* eslint-disable */
/**
 * Ubiquity REST API
 * Ubiquity provides a RESTful and uniform way to access blockchain resources, with a rich and reusable model across multiple cryptocurrencies.  [Documentation](https://app.blockdaemon.com/docs/ubiquity)  ### Protocols #### Mainnet The following protocols are currently supported: * bitcoin * ethereum * polkadot * xrp * algorand * stellar  #### Testnet Testnet support coming soon  ##### Pagination Certain resources contain a lot of data, more than what\'s practical to return for a single request. With the help of pagination, the data is split across multiple responses. Each response returns a subset of the items requested and a continuation token.  To get the next batch of items, copy the returned continuation token to the continuation query parameter and repeat the request with the new URL. In case no continuation token is returned, there is no more data available. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@blockdaemon.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Change of balance of a currency
 * @export
 * @interface BalanceChange
 */
export interface BalanceChange {
    /**
     * Balance before transaction
     * @type {string}
     * @memberof BalanceChange
     */
    old?: string;
    /**
     * Balance difference
     * @type {string}
     * @memberof BalanceChange
     */
    delta?: string;
    /**
     * Balance after transaction
     * @type {string}
     * @memberof BalanceChange
     */
    _new?: string;
    /**
     * 
     * @type {Currency}
     * @memberof BalanceChange
     */
    currency?: Currency;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * Block number
     * @type {number}
     * @memberof Block
     */
    number?: number;
    /**
     * Block hash
     * @type {string}
     * @memberof Block
     */
    id?: string;
    /**
     * Parent block hash
     * @type {string}
     * @memberof Block
     */
    parent_id?: string;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof Block
     */
    date?: number;
    /**
     * Complete list of transaction IDs
     * @type {Array<string>}
     * @memberof Block
     */
    tx_ids?: Array<string>;
    /**
     * Partial list of normalized transactions (not filtered or unknown model)
     * @type {Array<Tx>}
     * @memberof Block
     */
    txs?: Array<Tx>;
    /**
     * Coin supplies with asset paths as keys
     * @type {{ [key: string]: Supply; }}
     * @memberof Block
     */
    supply?: { [key: string]: Supply; };
}
/**
 * 
 * @export
 * @interface BlockIdentifier
 */
export interface BlockIdentifier {
    /**
     * Block number
     * @type {number}
     * @memberof BlockIdentifier
     */
    number?: number;
    /**
     * Block hash
     * @type {string}
     * @memberof BlockIdentifier
     */
    id?: string;
    /**
     * Parent block hash
     * @type {string}
     * @memberof BlockIdentifier
     */
    parent_id?: string;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * Platform handle (platform var in path)
     * @type {string}
     * @memberof Coin
     */
    handle?: string;
    /**
     * SatoshiLabs 0044, registered coin types: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
     * @type {number}
     * @memberof Coin
     */
    slip44?: number;
    /**
     * Symbol of native currency
     * @type {string}
     * @memberof Coin
     */
    symbol?: string;
    /**
     * Name of platform
     * @type {string}
     * @memberof Coin
     */
    name?: string;
    /**
     * Average time between blocks (milliseconds)
     * @type {number}
     * @memberof Coin
     */
    block_time?: number;
    /**
     * Random address seen on chain (optional)
     * @type {string}
     * @memberof Coin
     */
    sample_address?: string;
}
/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof Currency
     */
    asset_path?: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof Currency
     */
    symbol?: string;
    /**
     * Name of currency
     * @type {string}
     * @memberof Currency
     */
    name?: string;
    /**
     * Decimal places right to the comma
     * @type {number}
     * @memberof Currency
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    type?: CurrencyTypeEnum;
    /**
     * 
     * @type {CurrencyDetail}
     * @memberof Currency
     */
    detail?: CurrencyDetail;
}

/**
    * @export
    * @enum {string}
    */
export enum CurrencyTypeEnum {
    Native = 'native',
    Token = 'token',
    SmartToken = 'smart_token'
}

/**
 * @type CurrencyDetail
 * @export
 */
export type CurrencyDetail = SmartToken | Token;

/**
 * Effects are the state changes on an account
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * Balance changes by asset
     * @type {{ [key: string]: BalanceChange; }}
     * @memberof Effect
     */
    balance_changes?: { [key: string]: BalanceChange; };
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * HTTP error type
     * @type {string}
     * @memberof ModelError
     */
    type?: string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * Short error description
     * @type {string}
     * @memberof ModelError
     */
    title?: string;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof ModelError
     */
    status?: number;
    /**
     * Long error description
     * @type {string}
     * @memberof ModelError
     */
    detail?: string;
}
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    type?: OperationTypeEnum;
    /**
     * 
     * @type {OperationDetail}
     * @memberof Operation
     */
    detail?: OperationDetail;
}

/**
    * @export
    * @enum {string}
    */
export enum OperationTypeEnum {
    Transfer = 'transfer',
    UtxoTransfer = 'utxo_transfer',
    MultiTransfer = 'multi_transfer'
}

/**
 * @type OperationDetail
 * @export
 */
export type OperationDetail = Transfer | UtxoTransfer;

/**
 * 
 * @export
 * @interface PlatformDetail
 */
export interface PlatformDetail {
    /**
     * Backend API Type
     * @type {string}
     * @memberof PlatformDetail
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformDetail
     */
    handle?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformDetail
     */
    genesis_number?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlatformDetail
     */
    endpoints?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlatformEndpoint
 */
export interface PlatformEndpoint {
    /**
     * 
     * @type {string}
     * @memberof PlatformEndpoint
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformEndpoint
     */
    example?: string;
}
/**
 * 
 * @export
 * @interface SmartToken
 */
export interface SmartToken {
    /**
     * Name of token mechanism (smart contract)
     * @type {string}
     * @memberof SmartToken
     */
    type: string;
    /**
     * Address of contract
     * @type {string}
     * @memberof SmartToken
     */
    contract: string;
}
/**
 * 
 * @export
 * @interface Supply
 */
export interface Supply {
    /**
     * Maximum supply
     * @type {string}
     * @memberof Supply
     */
    maximum?: string;
    /**
     * Total supply at block height, excluding burnt coins
     * @type {string}
     * @memberof Supply
     */
    total?: string;
    /**
     * Total coins created historically up until this block
     * @type {string}
     * @memberof Supply
     */
    total_created?: string;
    /**
     * Total coins burnt historically up until this block
     * @type {string}
     * @memberof Supply
     */
    total_burnt?: string;
    /**
     * Coins created at this block
     * @type {string}
     * @memberof Supply
     */
    created?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * Name of token mechanism
     * @type {string}
     * @memberof Token
     */
    type: string;
    /**
     * Token identifier
     * @type {string}
     * @memberof Token
     */
    id: string;
    /**
     * Address that created token
     * @type {string}
     * @memberof Token
     */
    creator: string;
}
/**
 * Transfer of currency from one account to another
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * Sender address
     * @type {string}
     * @memberof Transfer
     */
    from: string;
    /**
     * Receiver address
     * @type {string}
     * @memberof Transfer
     */
    to: string;
    /**
     * 
     * @type {Currency}
     * @memberof Transfer
     */
    currency: Currency;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof Transfer
     */
    value: string;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * Unique transaction identifier
     * @type {string}
     * @memberof Tx
     */
    id?: string;
    /**
     * SLIP-44 coin ID
     * @type {number}
     * @memberof Tx
     */
    slip44?: number;
    /**
     * List of involved addresses (excluding contracts)
     * @type {Set<string>}
     * @memberof Tx
     */
    addresses?: Set<string> | null;
    /**
     * List of moved assets by asset path
     * @type {Set<string>}
     * @memberof Tx
     */
    assets?: Set<string> | null;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof Tx
     */
    date?: number;
    /**
     * Number of block if mined, otherwise omitted.
     * @type {number}
     * @memberof Tx
     */
    height?: number | null;
    /**
     * ID of block if mined, otherwise omitted.
     * @type {string}
     * @memberof Tx
     */
    block_id?: string | null;
    /**
     * Result status of the transaction.
     * @type {string}
     * @memberof Tx
     */
    status?: TxStatusEnum;
    /**
     * List of tags for this transaction
     * @type {Set<string>}
     * @memberof Tx
     */
    tags?: Set<string> | null;
    /**
     * Operations in this transaction (opaque keys).
     * @type {{ [key: string]: Operation; }}
     * @memberof Tx
     */
    operations?: { [key: string]: Operation; };
    /**
     * Effects by address, if supported
     * @type {{ [key: string]: Effect; }}
     * @memberof Tx
     */
    effects?: { [key: string]: Effect; };
}

/**
    * @export
    * @enum {string}
    */
export enum TxStatusEnum {
    Completed = 'completed',
    Failed = 'failed'
}

/**
 * 
 * @export
 * @interface TxPage
 */
export interface TxPage {
    /**
     * Number of items in txs
     * @type {number}
     * @memberof TxPage
     */
    total?: number;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxPage
     */
    items?: Array<Tx>;
    /**
     * Token to get the next page
     * @type {string}
     * @memberof TxPage
     */
    continuation?: string | null;
}
/**
 * An unspent transaction output
 * @export
 * @interface Utxo
 */
export interface Utxo {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof Utxo
     */
    asset_path?: string;
    /**
     * 
     * @type {string}
     * @memberof Utxo
     */
    address?: string;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof Utxo
     */
    value?: string;
}
/**
 * Transfer of currency in the UTXO model
 * @export
 * @interface UtxoTransfer
 */
export interface UtxoTransfer {
    /**
     * 
     * @type {Array<Utxo>}
     * @memberof UtxoTransfer
     */
    inputs: Array<Utxo>;
    /**
     * 
     * @type {Array<Utxo>}
     * @memberof UtxoTransfer
     */
    outputs: Array<Utxo>;
    /**
     * 
     * @type {Currency}
     * @memberof UtxoTransfer
     */
    currency: Currency;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof UtxoTransfer
     */
    unspent: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAddress: async (platform: string, network: string, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBalancesByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBalancesByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getBalancesByAddress', 'address', address)
            const localVarPath = `/{platform}/{network}/account/{address}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress: async (platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxsByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxsByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTxsByAddress', 'address', address)
            const localVarPath = `/{platform}/{network}/account/{address}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalancesByAddress(platform: string, network: string, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalancesByAddress(platform, network, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxsByAddress(platform, network, address, order, continuation, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAddress(platform: string, network: string, address: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getBalancesByAddress(platform, network, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options?: any): AxiosPromise<TxPage> {
            return localVarFp.getTxsByAddress(platform, network, address, order, continuation, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Returns the account balances for all supported currencies. 
     * @summary Balances Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getBalancesByAddress(platform: string, network: string, address: string, options?: any) {
        return AccountsApiFp(this.configuration).getBalancesByAddress(platform, network, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
     * @summary Transactions Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, options?: any) {
        return AccountsApiFp(this.configuration).getTxsByAddress(platform, network, address, order, continuation, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlocksApi - axios parameter creator
 * @export
 */
export const BlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: async (platform: string, network: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBlock', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBlock', 'network', network)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getBlock', 'key', key)
            const localVarPath = `/{platform}/{network}/block/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier: async (platform: string, network: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBlockIdentifier', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBlockIdentifier', 'network', network)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getBlockIdentifier', 'key', key)
            const localVarPath = `/{platform}/{network}/block_identifier/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocksApi - functional programming interface
 * @export
 */
export const BlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlock(platform: string, network: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(platform, network, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockIdentifier(platform: string, network: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockIdentifier(platform, network, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlocksApi - factory interface
 * @export
 */
export const BlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocksApiFp(configuration)
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(platform: string, network: string, key: string, options?: any): AxiosPromise<Block> {
            return localVarFp.getBlock(platform, network, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier(platform: string, network: string, key: string, options?: any): AxiosPromise<BlockIdentifier> {
            return localVarFp.getBlockIdentifier(platform, network, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
export class BlocksApi extends BaseAPI {
    /**
     * Get a block and all its transactions by the block number or hash
     * @summary Block By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlock(platform: string, network: string, key: string, options?: any) {
        return BlocksApiFp(this.configuration).getBlock(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get minimal block identifier by block number or hash
     * @summary Block Identifier By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlockIdentifier(platform: string, network: string, key: string, options?: any) {
        return BlocksApiFp(this.configuration).getBlockIdentifier(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlatformsApi - axios parameter creator
 * @export
 */
export const PlatformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatform: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getPlatform', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getPlatform', 'network', network)
            const localVarPath = `/{platform}/{network}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformsApi - functional programming interface
 * @export
 */
export const PlatformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatform(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatform(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlatformsApi - factory interface
 * @export
 */
export const PlatformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformsApiFp(configuration)
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatform(platform: string, network: string, options?: any): AxiosPromise<PlatformDetail> {
            return localVarFp.getPlatform(platform, network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformsApi - object-oriented interface
 * @export
 * @class PlatformsApi
 * @extends {BaseAPI}
 */
export class PlatformsApi extends BaseAPI {
    /**
     * Provides information about supported endpoints and generic platform information. 
     * @summary Platform Info
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public getPlatform(platform: string, network: string, options?: any) {
        return PlatformsApiFp(this.configuration).getPlatform(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SyncApi - axios parameter creator
 * @export
 */
export const SyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('currentBlockID', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('currentBlockID', 'network', network)
            const localVarPath = `/{platform}/{network}/sync/block_id`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('currentBlockNumber', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('currentBlockNumber', 'network', network)
            const localVarPath = `/{platform}/{network}/sync/block_number`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncApi - functional programming interface
 * @export
 */
export const SyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SyncApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentBlockID(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentBlockID(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentBlockNumber(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentBlockNumber(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SyncApi - factory interface
 * @export
 */
export const SyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SyncApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID(platform: string, network: string, options?: any): AxiosPromise<string> {
            return localVarFp.currentBlockID(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber(platform: string, network: string, options?: any): AxiosPromise<number> {
            return localVarFp.currentBlockNumber(platform, network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncApi - object-oriented interface
 * @export
 * @class SyncApi
 * @extends {BaseAPI}
 */
export class SyncApi extends BaseAPI {
    /**
     * 
     * @summary Get current block ID
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    public currentBlockID(platform: string, network: string, options?: any) {
        return SyncApiFp(this.configuration).currentBlockID(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current block number
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    public currentBlockNumber(platform: string, network: string, options?: any) {
        return SyncApiFp(this.configuration).currentBlockNumber(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: async (platform: string, network: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTx', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTx', 'network', network)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTx', 'id', id)
            const localVarPath = `/{platform}/{network}/tx/{id}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
         * @summary All Transactions
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs: async (platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxs', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxs', 'network', network)
            const localVarPath = `/{platform}/{network}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTx(platform: string, network: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTx(platform, network, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
         * @summary All Transactions
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxs(platform, network, order, continuation, limit, assets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(platform: string, network: string, id: string, options?: any): AxiosPromise<Tx> {
            return localVarFp.getTx(platform, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
         * @summary All Transactions
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): AxiosPromise<TxPage> {
            return localVarFp.getTxs(platform, network, order, continuation, limit, assets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary Transaction By Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTx(platform: string, network: string, id: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTx(platform, network, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
     * @summary All Transactions
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTxs(platform, network, order, continuation, limit, assets, options).then((request) => request(this.axios, this.basePath));
    }
}


