/* tslint:disable */
/* eslint-disable */
/**
 * Ubiquity REST API
 * Ubiquity provides a RESTful and uniform way to access blockchain resources, with a rich and reusable model across multiple cryptocurrencies.  [Documentation](https://app.blockdaemon.com/docs/ubiquity)  ### Protocols #### Mainnet The following protocols are currently supported: * bitcoin * ethereum * polkadot * xrp * algorand * stellar * dogecoin * oasis * stacks * near  #### Testnet * bitcoin/testnet * ethereum/ropsten * dogecoin/testnet  #### Native Ubiquity provides native access to all Blockchain nodes it supports. To access native functionality, use the protocol without the v2 prefix * bitcoin/(mainnet | testnet) - [RPC Documentation](https://developer.bitcoin.org/reference/rpc/) * ethereum/(mainnet | ropsten) - [RPC Documentation](https://ethereum.org/en/developers/docs/apis/json-rpc/) * polkadot/mainnet - [Sidecar API Documentation](https://paritytech.github.io/substrate-api-sidecar/dist/) * polkadot/mainnet/http-rpc - [Polkadot RPC Documentation](https://polkadot.js.org/docs/substrate/rpc/) * algorand/mainnet - [Algod API Documentation](https://developer.algorand.org/docs/reference/rest-apis/algod/v1/) * stellar/mainnet - [Stellar Horizon API Documentation](https://developers.stellar.org/api) * dogecoin/(mainnet | testnet) - [Dogecoin API Documentaion](https://developer.bitcoin.org/reference/rpc/) * oasis/mainnet - [Oasis Rosetta Gateway Documentation](https://www.rosetta-api.org/docs/api_identifiers.html#network-identifier) * stacks/mainnet - [Stacks API Documentation](https://blockstack.github.io/stacks-blockchain-api/) * near/mainnet - [NEAR RPC Documentation](https://docs.near.org/docs/api/rpc)  A full URL example: https://ubiquity.api.blockdaemon.com/bitcoin/mainnet  ##### Pagination Certain resources contain a lot of data, more than what\'s practical to return for a single request. With the help of pagination, the data is split across multiple responses. Each response returns a subset of the items requested, and a continuation token.  To get the next batch of items, copy the returned continuation token to the continuation query parameter and repeat the request with the new URL. In case no continuation token is returned, there is no more data available. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@blockdaemon.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountsObj
 */
export interface AccountsObj {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountsObj
     */
    addresses?: Array<string>;
}
/**
 * 
 * @export
 * @interface AlgorandMeta
 */
export interface AlgorandMeta {
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    sender_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    recipient_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    close?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    close_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorandMeta
     */
    close_reward?: string;
}
/**
 * Change of balance of a currency
 * @export
 * @interface BalanceChange
 */
export interface BalanceChange {
    /**
     * Balance before transaction
     * @type {string}
     * @memberof BalanceChange
     */
    old?: string;
    /**
     * Balance difference
     * @type {string}
     * @memberof BalanceChange
     */
    delta?: string;
    /**
     * Balance after transaction
     * @type {string}
     * @memberof BalanceChange
     */
    _new?: string;
    /**
     * 
     * @type {Currency}
     * @memberof BalanceChange
     */
    currency?: Currency;
}
/**
 * Currency balances with asset paths as keys
 * @export
 * @interface BalanceV1
 */
export interface BalanceV1 {
    /**
     * 
     * @type {Currency}
     * @memberof BalanceV1
     */
    currency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof BalanceV1
     */
    confirmed_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceV1
     */
    pending_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof BalanceV1
     */
    confirmed_nonce?: number;
    /**
     * 
     * @type {number}
     * @memberof BalanceV1
     */
    confirmed_block?: number;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * Block number
     * @type {number}
     * @memberof Block
     */
    number?: number;
    /**
     * Block hash
     * @type {string}
     * @memberof Block
     */
    id?: string;
    /**
     * Parent block hash
     * @type {string}
     * @memberof Block
     */
    parent_id?: string;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof Block
     */
    date?: number;
    /**
     * Complete list of transaction IDs
     * @type {Array<string>}
     * @memberof Block
     */
    tx_ids?: Array<string>;
    /**
     * Partial list of normalized transactions (not filtered or unknown model)
     * @type {Array<Tx>}
     * @memberof Block
     */
    txs?: Array<Tx>;
    /**
     * Coin supplies with asset paths as keys
     * @type {{ [key: string]: Supply; }}
     * @memberof Block
     */
    supply?: { [key: string]: Supply; };
}
/**
 * 
 * @export
 * @interface BlockIdentifier
 */
export interface BlockIdentifier {
    /**
     * Block number
     * @type {number}
     * @memberof BlockIdentifier
     */
    number?: number;
    /**
     * Block hash
     * @type {string}
     * @memberof BlockIdentifier
     */
    id?: string;
    /**
     * Parent block hash
     * @type {string}
     * @memberof BlockIdentifier
     */
    parent_id?: string;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * Platform handle (platform var in path)
     * @type {string}
     * @memberof Coin
     */
    handle?: string;
    /**
     * SatoshiLabs 0044, registered coin types: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
     * @type {number}
     * @memberof Coin
     */
    slip44?: number;
    /**
     * Symbol of native currency
     * @type {string}
     * @memberof Coin
     */
    symbol?: string;
    /**
     * Name of platform
     * @type {string}
     * @memberof Coin
     */
    name?: string;
    /**
     * Average time between blocks (milliseconds)
     * @type {number}
     * @memberof Coin
     */
    block_time?: number;
    /**
     * Random address seen on chain (optional)
     * @type {string}
     * @memberof Coin
     */
    sample_address?: string;
}
/**
 * @type Currency
 * @export
 */
export type Currency = NativeCurrency | SmartTokenCurrency | TokenCurrency;

/**
 * Effects are the state changes on an account
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * Balance changes by asset
     * @type {{ [key: string]: BalanceChange; }}
     * @memberof Effect
     */
    balance_changes?: { [key: string]: BalanceChange; };
}
/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof Fee
     */
    amount: string;
    /**
     * Destination
     * @type {string}
     * @memberof Fee
     */
    destination: string;
}
/**
 * 
 * @export
 * @interface FeeEstimate
 */
export interface FeeEstimate {
    /**
     * Most recent block
     * @type {number}
     * @memberof FeeEstimate
     */
    most_recent_block?: number;
    /**
     * 
     * @type {FeeEstimateEstimatedFees}
     * @memberof FeeEstimate
     */
    estimated_fees?: FeeEstimateEstimatedFees;
}
/**
 * Object containing fast, medium, slow fees
 * @export
 * @interface FeeEstimateEstimatedFees
 */
export interface FeeEstimateEstimatedFees {
    /**
     * 
     * @type {any}
     * @memberof FeeEstimateEstimatedFees
     */
    fast?: any | null;
    /**
     * 
     * @type {any}
     * @memberof FeeEstimateEstimatedFees
     */
    medium?: any | null;
    /**
     * 
     * @type {any}
     * @memberof FeeEstimateEstimatedFees
     */
    slow?: any | null;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * HTTP error type
     * @type {string}
     * @memberof ModelError
     */
    type?: string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * Short error description
     * @type {string}
     * @memberof ModelError
     */
    title?: string;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof ModelError
     */
    status?: number;
    /**
     * Long error description
     * @type {string}
     * @memberof ModelError
     */
    detail?: string;
}
/**
 * Transfer of currency in the UTXO model
 * @export
 * @interface MultiTransfer
 */
export interface MultiTransfer {
    /**
     * 
     * @type {Array<Utxo>}
     * @memberof MultiTransfer
     */
    inputs: Array<Utxo>;
    /**
     * 
     * @type {Array<Utxo>}
     * @memberof MultiTransfer
     */
    outputs: Array<Utxo>;
    /**
     * 
     * @type {Currency}
     * @memberof MultiTransfer
     */
    currency: Currency;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof MultiTransfer
     */
    total_in: string;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof MultiTransfer
     */
    total_out: string;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof MultiTransfer
     */
    unspent: string;
}
/**
 * 
 * @export
 * @interface MultiTransferOperation
 */
export interface MultiTransferOperation {
    /**
     * 
     * @type {string}
     * @memberof MultiTransferOperation
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof MultiTransferOperation
     */
    event?: string;
    /**
     * 
     * @type {MultiTransfer}
     * @memberof MultiTransferOperation
     */
    detail: MultiTransfer;
}
/**
 * 
 * @export
 * @interface NativeCurrency
 */
export interface NativeCurrency {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof NativeCurrency
     */
    asset_path: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof NativeCurrency
     */
    symbol?: string;
    /**
     * Name of currency
     * @type {string}
     * @memberof NativeCurrency
     */
    name?: string;
    /**
     * Decimal places right to the comma
     * @type {number}
     * @memberof NativeCurrency
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof NativeCurrency
     */
    type: string;
}
/**
 * @type Operation
 * @export
 */
export type Operation = MultiTransferOperation | TransferOperation;

/**
 * 
 * @export
 * @interface PlatformDetail
 */
export interface PlatformDetail {
    /**
     * Backend API Type
     * @type {string}
     * @memberof PlatformDetail
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformDetail
     */
    handle?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformDetail
     */
    genesis_number?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlatformDetail
     */
    endpoints?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlatformEndpoint
 */
export interface PlatformEndpoint {
    /**
     * 
     * @type {string}
     * @memberof PlatformEndpoint
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformEndpoint
     */
    example?: string;
}
/**
 * 
 * @export
 * @interface PlatformsOverview
 */
export interface PlatformsOverview {
    /**
     * List of items each describing a pair of supported platform and network.
     * @type {Array<PlatformsOverviewPlatforms>}
     * @memberof PlatformsOverview
     */
    platforms?: Array<PlatformsOverviewPlatforms>;
}
/**
 * 
 * @export
 * @interface PlatformsOverviewPlatforms
 */
export interface PlatformsOverviewPlatforms {
    /**
     * 
     * @type {string}
     * @memberof PlatformsOverviewPlatforms
     */
    handle?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformsOverviewPlatforms
     */
    network?: string;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * Transaction items
     * @type {Array<ReportField>}
     * @memberof Report
     */
    fields: Array<ReportField>;
    /**
     * The number of transactions in the report
     * @type {number}
     * @memberof Report
     */
    items: number;
}
/**
 * 
 * @export
 * @interface ReportField
 */
export interface ReportField {
    /**
     * The protocol the address relates to
     * @type {string}
     * @memberof ReportField
     */
    protocol: string;
    /**
     * The wallet/account the transaction occurred
     * @type {string}
     * @memberof ReportField
     */
    address: string;
    /**
     * The currency symbol
     * @type {string}
     * @memberof ReportField
     */
    currency: string;
    /**
     * The ID of the event within a transaction
     * @type {string}
     * @memberof ReportField
     */
    event_id: string;
    /**
     * The block number the transaction occurred on
     * @type {number}
     * @memberof ReportField
     */
    block: number;
    /**
     * The unix timestamp when the transaction was added to a block
     * @type {number}
     * @memberof ReportField
     */
    timestamp: number;
    /**
     * The transaction ID
     * @type {string}
     * @memberof ReportField
     */
    hash: string;
    /**
     * The action type e.g. Transfer, Deposit, Staking Reward etc..
     * @type {string}
     * @memberof ReportField
     */
    action: string;
    /**
     * The amount of currency involved in the transaction (smallest unit)
     * @type {string}
     * @memberof ReportField
     */
    value: string;
    /**
     * The address where the funds originated
     * @type {string}
     * @memberof ReportField
     */
    sender_address: string;
    /**
     * How much was charged as a fee for processing the transaction
     * @type {string}
     * @memberof ReportField
     */
    fee: string;
    /**
     * The number of decimals in one coin, used to convert smallest unit to 1 whole coin if needed
     * @type {number}
     * @memberof ReportField
     */
    decimals: number;
    /**
     * 
     * @type {ReportFieldMeta}
     * @memberof ReportField
     */
    meta?: ReportFieldMeta | null;
}
/**
 * @type ReportFieldMeta
 * Additional metadata bespoke to specific protocols
 * @export
 */
export type ReportFieldMeta = AlgorandMeta;

/**
 * 
 * @export
 * @interface SignedTx
 */
export interface SignedTx {
    /**
     * The signed TX
     * @type {string}
     * @memberof SignedTx
     */
    tx: string;
}
/**
 * 
 * @export
 * @interface SmartToken
 */
export interface SmartToken {
    /**
     * Name of token mechanism (smart contract)
     * @type {string}
     * @memberof SmartToken
     */
    type: string;
    /**
     * Address of contract
     * @type {string}
     * @memberof SmartToken
     */
    contract: string;
}
/**
 * 
 * @export
 * @interface SmartTokenCurrency
 */
export interface SmartTokenCurrency {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    asset_path: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    symbol?: string;
    /**
     * Name of currency
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    name?: string;
    /**
     * Decimal places right to the comma
     * @type {number}
     * @memberof SmartTokenCurrency
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof SmartTokenCurrency
     */
    type: string;
    /**
     * 
     * @type {SmartToken}
     * @memberof SmartTokenCurrency
     */
    detail?: SmartToken;
}
/**
 * 
 * @export
 * @interface Supply
 */
export interface Supply {
    /**
     * Maximum supply
     * @type {string}
     * @memberof Supply
     */
    maximum?: string;
    /**
     * Total supply at block height, excluding burnt coins
     * @type {string}
     * @memberof Supply
     */
    total?: string;
    /**
     * Total coins created historically up until this block
     * @type {string}
     * @memberof Supply
     */
    total_created?: string;
    /**
     * Total coins burnt historically up until this block
     * @type {string}
     * @memberof Supply
     */
    total_burnt?: string;
    /**
     * Coins created at this block
     * @type {string}
     * @memberof Supply
     */
    created?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * Name of token mechanism
     * @type {string}
     * @memberof Token
     */
    type: string;
    /**
     * Token identifier
     * @type {string}
     * @memberof Token
     */
    id: string;
    /**
     * Address that created token
     * @type {string}
     * @memberof Token
     */
    creator?: string;
}
/**
 * 
 * @export
 * @interface TokenCurrency
 */
export interface TokenCurrency {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof TokenCurrency
     */
    asset_path: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof TokenCurrency
     */
    symbol?: string;
    /**
     * Name of currency
     * @type {string}
     * @memberof TokenCurrency
     */
    name?: string;
    /**
     * Decimal places right to the comma
     * @type {number}
     * @memberof TokenCurrency
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenCurrency
     */
    type: string;
    /**
     * 
     * @type {Token}
     * @memberof TokenCurrency
     */
    detail?: Token;
}
/**
 * Transfer of currency from one account to another
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * Sender address
     * @type {string}
     * @memberof Transfer
     */
    from: string;
    /**
     * Receiver address
     * @type {string}
     * @memberof Transfer
     */
    to: string;
    /**
     * 
     * @type {Currency}
     * @memberof Transfer
     */
    currency: Currency;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof Transfer
     */
    value: string;
    /**
     * 
     * @type {Fee}
     * @memberof Transfer
     */
    fee?: Fee;
}
/**
 * 
 * @export
 * @interface TransferOperation
 */
export interface TransferOperation {
    /**
     * 
     * @type {string}
     * @memberof TransferOperation
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof TransferOperation
     */
    event?: string;
    /**
     * 
     * @type {Transfer}
     * @memberof TransferOperation
     */
    detail: Transfer;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * Unique transaction identifier
     * @type {string}
     * @memberof Tx
     */
    id?: string;
    /**
     * SLIP-44 coin ID
     * @type {number}
     * @memberof Tx
     */
    slip44?: number;
    /**
     * List of involved addresses (excluding contracts)
     * @type {Set<string>}
     * @memberof Tx
     */
    addresses?: Set<string> | null;
    /**
     * List of moved assets by asset path
     * @type {Set<string>}
     * @memberof Tx
     */
    assets?: Set<string> | null;
    /**
     * Unix timestamp
     * @type {number}
     * @memberof Tx
     */
    date?: number;
    /**
     * Number of block if mined, otherwise omitted.
     * @type {number}
     * @memberof Tx
     */
    height?: number | null;
    /**
     * ID of block if mined, otherwise omitted.
     * @type {string}
     * @memberof Tx
     */
    block_id?: string | null;
    /**
     * Result status of the transaction.
     * @type {string}
     * @memberof Tx
     */
    status?: TxStatusEnum;
    /**
     * List of tags for this transaction
     * @type {Set<string>}
     * @memberof Tx
     */
    tags?: Set<string> | null;
    /**
     * Operations in this transaction (opaque keys).
     * @type {{ [key: string]: Operation; }}
     * @memberof Tx
     */
    operations?: { [key: string]: Operation; };
    /**
     * Effects by address, if supported
     * @type {{ [key: string]: Effect; }}
     * @memberof Tx
     */
    effects?: { [key: string]: Effect; };
}

/**
    * @export
    * @enum {string}
    */
export enum TxStatusEnum {
    Completed = 'completed',
    Failed = 'failed'
}

/**
 * A list of recipients
 * @export
 * @interface TxDestination
 */
export interface TxDestination {
    /**
     * 
     * @type {string}
     * @memberof TxDestination
     */
    destination: string;
    /**
     * The amount you wish to transfer
     * @type {string}
     * @memberof TxDestination
     */
    amount: string;
}
/**
 * 
 * @export
 * @interface TxPage
 */
export interface TxPage {
    /**
     * Number of items in txs
     * @type {number}
     * @memberof TxPage
     */
    total?: number;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxPage
     */
    items?: Array<Tx>;
    /**
     * Token to get the next page
     * @type {string}
     * @memberof TxPage
     */
    continuation?: string | null;
}
/**
 * 
 * @export
 * @interface TxReceipt
 */
export interface TxReceipt {
    /**
     * The transaction ID
     * @type {string}
     * @memberof TxReceipt
     */
    id: string;
}
/**
 * An unspent transaction output
 * @export
 * @interface Utxo
 */
export interface Utxo {
    /**
     * Asset path of transferred currency
     * @type {string}
     * @memberof Utxo
     */
    asset_path?: string;
    /**
     * 
     * @type {string}
     * @memberof Utxo
     */
    address?: string;
    /**
     * Integer string in smallest unit (Satoshis)
     * @type {string}
     * @memberof Utxo
     */
    value?: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAddress: async (platform: string, network: string, address: string, assets?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBalancesByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBalancesByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getBalancesByAddress', 'address', address)
            const localVarPath = `/v2/{platform}/{network}/account/{address}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAddresses: async (platform: string, network: string, accountsObj: AccountsObj, assets?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBalancesByAddresses', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBalancesByAddresses', 'network', network)
            // verify required parameter 'accountsObj' is not null or undefined
            assertParamExists('getBalancesByAddresses', 'accountsObj', accountsObj)
            const localVarPath = `/v2/{platform}/{network}/accounts`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddress: async (platform: string, network: string, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getListOfBalancesByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getListOfBalancesByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getListOfBalancesByAddress', 'address', address)
            const localVarPath = `/v1/{platform}/{network}/account/{address}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddresses: async (platform: string, network: string, accountsObj: AccountsObj, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getListOfBalancesByAddresses', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getListOfBalancesByAddresses', 'network', network)
            // verify required parameter 'accountsObj' is not null or undefined
            assertParamExists('getListOfBalancesByAddresses', 'accountsObj', accountsObj)
            const localVarPath = `/v1/{platform}/{network}/accounts`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns account activity 
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportByAddress: async (platform: string, network: string, address: string, from?: number, to?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getReportByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getReportByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReportByAddress', 'address', address)
            const localVarPath = `/v2/{platform}/{network}/account/{address}/report`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress: async (platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxsByAddress', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxsByAddress', 'network', network)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTxsByAddress', 'address', address)
            const localVarPath = `/v2/{platform}/{network}/account/{address}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalancesByAddress(platform: string, network: string, address: string, assets?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalancesByAddress(platform, network, address, assets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, assets?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: object; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalancesByAddresses(platform, network, accountsObj, assets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfBalancesByAddress(platform: string, network: string, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceV1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfBalancesByAddress(platform, network, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<BalanceV1>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfBalancesByAddresses(platform, network, accountsObj, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns account activity 
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportByAddress(platform: string, network: string, address: string, from?: number, to?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportByAddress(platform, network, address, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxsByAddress(platform, network, address, order, continuation, limit, assets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAddress(platform: string, network: string, address: string, assets?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getBalancesByAddress(platform, network, address, assets, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, assets?: string, options?: any): AxiosPromise<{ [key: string]: { [key: string]: object; }; }> {
            return localVarFp.getBalancesByAddresses(platform, network, accountsObj, assets, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account balances for all supported currencies. 
         * @summary Balances Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddress(platform: string, network: string, address: string, options?: any): AxiosPromise<Array<BalanceV1>> {
            return localVarFp.getListOfBalancesByAddress(platform, network, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the balances of accounts for all supported currencies. 
         * @summary Balances Of Addresses
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {AccountsObj} accountsObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, options?: any): AxiosPromise<{ [key: string]: Array<BalanceV1>; }> {
            return localVarFp.getListOfBalancesByAddresses(platform, network, accountsObj, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns account activity 
         * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {number} [from] Unix Timestamp from where to start
         * @param {number} [to] Unix Timestamp from where to end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportByAddress(platform: string, network: string, address: string, from?: number, to?: number, options?: any): AxiosPromise<Report> {
            return localVarFp.getReportByAddress(platform, network, address, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
         * @summary Transactions Of Address
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} address Account address
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): AxiosPromise<TxPage> {
            return localVarFp.getTxsByAddress(platform, network, address, order, continuation, limit, assets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Returns the account balances for all supported currencies. 
     * @summary Balances Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getBalancesByAddress(platform: string, network: string, address: string, assets?: string, options?: any) {
        return AccountsApiFp(this.configuration).getBalancesByAddress(platform, network, address, assets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the balances of accounts for all supported currencies. 
     * @summary Balances Of Addresses
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {AccountsObj} accountsObj 
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, assets?: string, options?: any) {
        return AccountsApiFp(this.configuration).getBalancesByAddresses(platform, network, accountsObj, assets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the account balances for all supported currencies. 
     * @summary Balances Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getListOfBalancesByAddress(platform: string, network: string, address: string, options?: any) {
        return AccountsApiFp(this.configuration).getListOfBalancesByAddress(platform, network, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the balances of accounts for all supported currencies. 
     * @summary Balances Of Addresses
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {AccountsObj} accountsObj 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getListOfBalancesByAddresses(platform: string, network: string, accountsObj: AccountsObj, options?: any) {
        return AccountsApiFp(this.configuration).getListOfBalancesByAddresses(platform, network, accountsObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns account activity 
     * @summary A financial report for an address between a time period. Default timescale is within the last 30 days
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {number} [from] Unix Timestamp from where to start
     * @param {number} [to] Unix Timestamp from where to end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getReportByAddress(platform: string, network: string, address: string, from?: number, to?: number, options?: any) {
        return AccountsApiFp(this.configuration).getReportByAddress(platform, network, address, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets transactions that an address was involved with, from newest to oldest. This call uses pagination. 
     * @summary Transactions Of Address
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} address Account address
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getTxsByAddress(platform: string, network: string, address: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any) {
        return AccountsApiFp(this.configuration).getTxsByAddress(platform, network, address, order, continuation, limit, assets, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlocksApi - axios parameter creator
 * @export
 */
export const BlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: async (platform: string, network: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBlock', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBlock', 'network', network)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getBlock', 'key', key)
            const localVarPath = `/v2/{platform}/{network}/block/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier: async (platform: string, network: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getBlockIdentifier', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getBlockIdentifier', 'network', network)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getBlockIdentifier', 'key', key)
            const localVarPath = `/v2/{platform}/{network}/block_identifier/{key}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocksApi - functional programming interface
 * @export
 */
export const BlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlock(platform: string, network: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(platform, network, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockIdentifier(platform: string, network: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockIdentifier(platform, network, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlocksApi - factory interface
 * @export
 */
export const BlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocksApiFp(configuration)
    return {
        /**
         * Get a block and all its transactions by the block number or hash
         * @summary Block By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(platform: string, network: string, key: string, options?: any): AxiosPromise<Block> {
            return localVarFp.getBlock(platform, network, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get minimal block identifier by block number or hash
         * @summary Block Identifier By Number/Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} key Block number or block hash/ID or Special identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockIdentifier(platform: string, network: string, key: string, options?: any): AxiosPromise<BlockIdentifier> {
            return localVarFp.getBlockIdentifier(platform, network, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
export class BlocksApi extends BaseAPI {
    /**
     * Get a block and all its transactions by the block number or hash
     * @summary Block By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlock(platform: string, network: string, key: string, options?: any) {
        return BlocksApiFp(this.configuration).getBlock(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get minimal block identifier by block number or hash
     * @summary Block Identifier By Number/Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} key Block number or block hash/ID or Special identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlockIdentifier(platform: string, network: string, key: string, options?: any) {
        return BlocksApiFp(this.configuration).getBlockIdentifier(platform, network, key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlatformsApi - axios parameter creator
 * @export
 */
export const PlatformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatform: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getPlatform', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getPlatform', 'network', network)
            const localVarPath = `/v2/{platform}/{network}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformEndpoints: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getPlatformEndpoints', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getPlatformEndpoints', 'network', network)
            const localVarPath = `/v1/{platform}/{network}/`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatforms: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformsApi - functional programming interface
 * @export
 */
export const PlatformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatform(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatform(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformEndpoints(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformEndpoints(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatforms(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformsOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatforms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformsList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformsOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlatformsApi - factory interface
 * @export
 */
export const PlatformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformsApiFp(configuration)
    return {
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatform(platform: string, network: string, options?: any): AxiosPromise<PlatformDetail> {
            return localVarFp.getPlatform(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides information about supported endpoints and generic platform information. 
         * @summary Platform Info
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformEndpoints(platform: string, network: string, options?: any): AxiosPromise<PlatformDetail> {
            return localVarFp.getPlatformEndpoints(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatforms(options?: any): AxiosPromise<PlatformsOverview> {
            return localVarFp.getPlatforms(options).then((request) => request(axios, basePath));
        },
        /**
         * Provides a list of supported platforms and networks. 
         * @summary Platforms overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsList(options?: any): AxiosPromise<PlatformsOverview> {
            return localVarFp.getPlatformsList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformsApi - object-oriented interface
 * @export
 * @class PlatformsApi
 * @extends {BaseAPI}
 */
export class PlatformsApi extends BaseAPI {
    /**
     * Provides information about supported endpoints and generic platform information. 
     * @summary Platform Info
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public getPlatform(platform: string, network: string, options?: any) {
        return PlatformsApiFp(this.configuration).getPlatform(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides information about supported endpoints and generic platform information. 
     * @summary Platform Info
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public getPlatformEndpoints(platform: string, network: string, options?: any) {
        return PlatformsApiFp(this.configuration).getPlatformEndpoints(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a list of supported platforms and networks. 
     * @summary Platforms overview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public getPlatforms(options?: any) {
        return PlatformsApiFp(this.configuration).getPlatforms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a list of supported platforms and networks. 
     * @summary Platforms overview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformsApi
     */
    public getPlatformsList(options?: any) {
        return PlatformsApiFp(this.configuration).getPlatformsList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SyncApi - axios parameter creator
 * @export
 */
export const SyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('currentBlockID', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('currentBlockID', 'network', network)
            const localVarPath = `/v2/{platform}/{network}/sync/block_id`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('currentBlockNumber', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('currentBlockNumber', 'network', network)
            const localVarPath = `/v2/{platform}/{network}/sync/block_number`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncApi - functional programming interface
 * @export
 */
export const SyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SyncApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentBlockID(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentBlockID(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentBlockNumber(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentBlockNumber(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SyncApi - factory interface
 * @export
 */
export const SyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SyncApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current block ID
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockID(platform: string, network: string, options?: any): AxiosPromise<string> {
            return localVarFp.currentBlockID(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current block number
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentBlockNumber(platform: string, network: string, options?: any): AxiosPromise<number> {
            return localVarFp.currentBlockNumber(platform, network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncApi - object-oriented interface
 * @export
 * @class SyncApi
 * @extends {BaseAPI}
 */
export class SyncApi extends BaseAPI {
    /**
     * 
     * @summary Get current block ID
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    public currentBlockID(platform: string, network: string, options?: any) {
        return SyncApiFp(this.configuration).currentBlockID(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current block number
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    public currentBlockNumber(platform: string, network: string, options?: any) {
        return SyncApiFp(this.configuration).currentBlockNumber(platform, network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a fee estimation in decimals from the network. If supported by the platform, the number of blocks used to make the estimation can be customized by the confirmed_within_blocks query parameter. 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {number} [confirmedWithinBlocks] The number of blocks you would like the transaction to be processed within. Lower numbers produce higher fees. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateFee: async (platform: string, network: string, confirmedWithinBlocks?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('estimateFee', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('estimateFee', 'network', network)
            const localVarPath = `/v2/{platform}/{network}/tx/estimate_fee`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (confirmedWithinBlocks !== undefined) {
                localVarQueryParameter['confirmed_within_blocks'] = confirmedWithinBlocks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEstimate: async (platform: string, network: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('feeEstimate', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('feeEstimate', 'network', network)
            const localVarPath = `/v1/{platform}/{network}/tx/estimate_fee`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: async (platform: string, network: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTx', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTx', 'network', network)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTx', 'id', id)
            const localVarPath = `/v2/{platform}/{network}/tx/{id}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
         * @summary All Transactions
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs: async (platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getTxs', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTxs', 'network', network)
            const localVarPath = `/v2/{platform}/{network}/txs`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSend: async (platform: string, network: string, signedTx: SignedTx, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('txSend', 'platform', platform)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('txSend', 'network', network)
            // verify required parameter 'signedTx' is not null or undefined
            assertParamExists('txSend', 'signedTx', signedTx)
            const localVarPath = `/v2/{platform}/{network}/tx/send`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signedTx, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a fee estimation in decimals from the network. If supported by the platform, the number of blocks used to make the estimation can be customized by the confirmed_within_blocks query parameter. 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {number} [confirmedWithinBlocks] The number of blocks you would like the transaction to be processed within. Lower numbers produce higher fees. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateFee(platform: string, network: string, confirmedWithinBlocks?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateFee(platform, network, confirmedWithinBlocks, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feeEstimate(platform: string, network: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeEstimate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feeEstimate(platform, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTx(platform: string, network: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTx(platform, network, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
         * @summary All Transactions
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxs(platform, network, order, continuation, limit, assets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txSend(platform: string, network: string, signedTx: SignedTx, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxReceipt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txSend(platform, network, signedTx, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Get a fee estimation in decimals from the network. If supported by the platform, the number of blocks used to make the estimation can be customized by the confirmed_within_blocks query parameter. 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {number} [confirmedWithinBlocks] The number of blocks you would like the transaction to be processed within. Lower numbers produce higher fees. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateFee(platform: string, network: string, confirmedWithinBlocks?: number, options?: any): AxiosPromise<string> {
            return localVarFp.estimateFee(platform, network, confirmedWithinBlocks, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
         * @summary Get fee estimate
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEstimate(platform: string, network: string, options?: any): AxiosPromise<FeeEstimate> {
            return localVarFp.feeEstimate(platform, network, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transaction By Hash
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {string} id Transaction ID/Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(platform: string, network: string, id: string, options?: any): AxiosPromise<Tx> {
            return localVarFp.getTx(platform, network, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
         * @summary All Transactions
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {'desc' | 'asc'} [order] Pagination order
         * @param {string} [continuation] Continuation token from earlier response
         * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
         * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any): AxiosPromise<TxPage> {
            return localVarFp.getTxs(platform, network, order, continuation, limit, assets, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
         * @summary Submit a signed transaction
         * @param {string} platform Coin platform handle
         * @param {string} network Which network to target. Available networks can be found with /{platform}
         * @param {SignedTx} signedTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSend(platform: string, network: string, signedTx: SignedTx, options?: any): AxiosPromise<TxReceipt> {
            return localVarFp.txSend(platform, network, signedTx, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Get a fee estimation in decimals from the network. If supported by the platform, the number of blocks used to make the estimation can be customized by the confirmed_within_blocks query parameter. 
     * @summary Get fee estimate
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {number} [confirmedWithinBlocks] The number of blocks you would like the transaction to be processed within. Lower numbers produce higher fees. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public estimateFee(platform: string, network: string, confirmedWithinBlocks?: number, options?: any) {
        return TransactionsApiFp(this.configuration).estimateFee(platform, network, confirmedWithinBlocks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a fee estimation in decimals from the ubiquity fee estimation service. Currently supported for Bitcoin and Ethereum. Endpoint will return 3 fee estimations fast, medium and slow 
     * @summary Get fee estimate
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public feeEstimate(platform: string, network: string, options?: any) {
        return TransactionsApiFp(this.configuration).feeEstimate(platform, network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transaction By Hash
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {string} id Transaction ID/Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTx(platform: string, network: string, id: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTx(platform, network, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions on the platform, starting with the lastest one. Each call returns a slice of the entire list. Use the returned continuation token to get the next part.
     * @summary All Transactions
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {'desc' | 'asc'} [order] Pagination order
     * @param {string} [continuation] Continuation token from earlier response
     * @param {number} [limit] Max number of items to return in a response. Defaults to 25 and is capped at 100. 
     * @param {string} [assets] Comma-separated list of asset paths to filter. If the list is empty, or all elements are empty, this filter has no effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTxs(platform: string, network: string, order?: 'desc' | 'asc', continuation?: string, limit?: number, assets?: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTxs(platform, network, order, continuation, limit, assets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed transaction to the network.  **Note**: A successful transaction may still be rejected on chain or not processed due to a too low fee. You can monitor successful transactions through Ubiquity websockets. 
     * @summary Submit a signed transaction
     * @param {string} platform Coin platform handle
     * @param {string} network Which network to target. Available networks can be found with /{platform}
     * @param {SignedTx} signedTx 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txSend(platform: string, network: string, signedTx: SignedTx, options?: any) {
        return TransactionsApiFp(this.configuration).txSend(platform, network, signedTx, options).then((request) => request(this.axios, this.basePath));
    }
}


